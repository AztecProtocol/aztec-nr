//! Aztec hash functions.

use crate::protocol::{
    address::{AztecAddress, EthAddress},
    constants::{
        DOM_SEP__FUNCTION_ARGS, DOM_SEP__MESSAGE_NULLIFIER, DOM_SEP__PUBLIC_BYTECODE, DOM_SEP__PUBLIC_CALLDATA,
        DOM_SEP__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,
    },
    hash::{poseidon2_hash_subarray, poseidon2_hash_with_separator, sha256_to_field},
    traits::ToField,
};

pub use crate::protocol::hash::compute_siloed_nullifier;

pub fn compute_secret_hash(secret: Field) -> Field {
    poseidon2_hash_with_separator([secret], DOM_SEP__SECRET_HASH)
}

pub fn compute_l1_to_l2_message_hash(
    sender: EthAddress,
    chain_id: Field,
    recipient: AztecAddress,
    version: Field,
    content: Field,
    secret_hash: Field,
    leaf_index: Field,
) -> Field {
    let mut hash_bytes = [0 as u8; 224];
    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();
    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();
    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();
    let version_bytes: [u8; 32] = version.to_be_bytes();
    let content_bytes: [u8; 32] = content.to_be_bytes();
    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();
    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();

    for i in 0..32 {
        hash_bytes[i] = sender_bytes[i];
        hash_bytes[i + 32] = chain_id_bytes[i];
        hash_bytes[i + 64] = recipient_bytes[i];
        hash_bytes[i + 96] = version_bytes[i];
        hash_bytes[i + 128] = content_bytes[i];
        hash_bytes[i + 160] = secret_hash_bytes[i];
        hash_bytes[i + 192] = leaf_index_bytes[i];
    }

    sha256_to_field(hash_bytes)
}

// The nullifier of a l1 to l2 message is the hash of the message salted with the secret
pub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {
    poseidon2_hash_with_separator([message_hash, secret], DOM_SEP__MESSAGE_NULLIFIER)
}

// Computes the hash of input arguments or return values for private functions, or for authwit creation.
pub fn hash_args<let N: u32>(args: [Field; N]) -> Field {
    if args.len() == 0 {
        0
    } else {
        poseidon2_hash_with_separator(args, DOM_SEP__FUNCTION_ARGS)
    }
}

// Computes the hash of calldata for public functions.
pub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {
    poseidon2_hash_with_separator(calldata, DOM_SEP__PUBLIC_CALLDATA)
}

/// Computes the public bytecode commitment for a contract class. The commitment is `hash([(length | separator),
/// ...bytecode])`.
///
/// @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.
/// packed_bytecode is mutable so that we can avoid copying the array to construct one starting with first_field
/// instead of length. @returns The public bytecode commitment.
pub fn compute_public_bytecode_commitment(
    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],
) -> Field {
    // First field element contains the length of the bytecode
    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;
    let bytecode_length_in_fields: u32 = (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;
    // Don't allow empty public bytecode. AVM doesn't handle execution of contracts that exist with empty bytecode.
    assert(bytecode_length_in_fields != 0);
    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);

    // Packed_bytecode's 0th entry is the length. Append it to the separator before hashing.
    let first_field = DOM_SEP__PUBLIC_BYTECODE.to_field() + (packed_public_bytecode[0] as u64 << 32) as Field;
    packed_public_bytecode[0] = first_field;

    // `fields_to_hash` is the number of fields from the start of `packed_public_bytecode` that should be included in
    // the hash. Fields after this length are ignored. +1 to account for the prepended field.
    let num_fields_to_hash = bytecode_length_in_fields + 1;

    poseidon2_hash_subarray(packed_public_bytecode, num_fields_to_hash)
}

#[test]
unconstrained fn secret_hash_matches_typescript() {
    let secret = 8;
    let hash = compute_secret_hash(secret);

    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`
    let secret_hash_from_ts = 0x1848b066724ab0ffb50ecb0ee3398eb839f162823d262bad959721a9c13d1e96;

    assert_eq(hash, secret_hash_from_ts);
}

#[test]
unconstrained fn var_args_hash_matches_typescript() {
    let mut input = [0; 100];
    for i in 0..100 {
        input[i] = i as Field;
    }
    let hash = hash_args(input);

    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`
    let var_args_hash_from_ts = 0x262e5e121a8efc0382566ab42f0ae2a78bd85db88484f83018fe07fc2552ba0c;

    assert_eq(hash, var_args_hash_from_ts);
}

#[test]
unconstrained fn compute_calldata_hash() {
    let mut input = [0; 100];
    for i in 0..input.len() {
        input[i] = i as Field;
    }
    let hash = hash_calldata_array(input);

    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`
    let calldata_hash_from_ts = 0x14a1539bdb1d26e03097cf4d40c87e02ca03f0bb50a3e617ace5a7bfd3943944;

    // Used in cpp vm2 tests:
    assert_eq(hash, calldata_hash_from_ts);
}

#[test]
unconstrained fn public_bytecode_commitment() {
    let mut input = [0; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS];
    let len = 99;
    for i in 1..len + 1 {
        input[i] = i as Field;
    }
    input[0] = (len as Field) * 31;
    let hash = compute_public_bytecode_commitment(input);
    // Used in cpp vm2 tests:
    assert_eq(hash, 0x09348974e76c3602893d7a4b4bb52c2ec746f1ade5004ac471d0fbb4587a81a6);
}
