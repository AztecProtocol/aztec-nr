//! Stubs are auto-generated wrapper functions that provide an ergonomic interface for cross-contract calls.
//! Instead of manually serializing arguments and creating call interfaces, stubs allow natural syntax, e.g. for
//! enqueuing calls to public functions:
//!
//!   ExternalContract.at(address).some_method(arg1, arg2).enqueue()

use crate::macros::utils::{AsStrQuote, compute_fn_selector};
use protocol_types::meta::utils::derive_serialization_quotes;
use std::meta::unquote;

comptime global FROM_FIELD: TypedExpr = {
    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();
    let function_selector_typ =
        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();
    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {
        m.name() == quote { from_field }
    })[0]
        .as_typed_expr()
};

/// Utility function creating stubs used by all the stub functions in this file.
comptime fn create_stub_base(
    f: FunctionDefinition,
) -> (Quoted, Quoted, Quoted, Quoted, u32, Quoted, u32, Field) {
    // Dear privacy adventurer,
    // Chances are, you've command+clicked on the name of an external function
    // call -- seeking to view that function -- only to end up here.
    // Here's an explanation:
    // The external contract that you're calling was likely annotated with the `#[aztec]`
    // annotation -- as all good aztec contracts are. This triggers a macro which generates
    // a "contract interface" for that contract, which is effectively a pretty interface
    // that gives natural contract calling semantics:
    //
    // `MyImportedContract.at(some_address).my_method(arg1, arg2).enqueue();
    //
    // Unfortunately, the usage of macros makes it a bit of a black box.
    // To actually view the target function, you could instead command+click on
    // `MyImportedContract`, or you can just manually search it.
    // If you want to view the noir code that gets generated by this macro, you can
    // use `nargo expand` on your contract.
    let fn_name = f.name();
    let fn_parameters = f.parameters();
    let fn_parameters_list =
        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});

    let (serialized_args_array_construction, serialized_args_array_len_quote, serialized_args_array_name) =
        derive_serialization_quotes(fn_parameters, false);
    let serialized_args_array_len: u32 =
        unquote!(quote { ($serialized_args_array_len_quote) as u32 });

    let (fn_name_str, _) = fn_name.as_str_quote();
    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});
    let fn_selector: Field = compute_fn_selector(f);

    (
        fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name,
        serialized_args_array_len, fn_name_str, fn_name_len, fn_selector,
    )
}

pub(crate) comptime fn create_private_stub(f: FunctionDefinition) -> Quoted {
    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =
        create_stub_base(f);
    let fn_return_type = f.return_type();

    quote {
        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::PrivateCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {
            $serialized_args_array_construction
            let selector = $FROM_FIELD($fn_selector);
            dep::aztec::context::calls::PrivateCall::new(
                self.target_contract,
                selector,
                $fn_name_str,
                $serialized_args_array_name,
            )
        }
    }
}

pub(crate) comptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {
    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =
        create_stub_base(f);
    let fn_return_type = f.return_type();

    quote {
        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::PrivateStaticCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {
            $serialized_args_array_construction
            let selector = $FROM_FIELD($fn_selector);
            dep::aztec::context::calls::PrivateStaticCall::new(
                self.target_contract,
                selector,
                $fn_name_str,
                $serialized_args_array_name,
            )
        }
    }
}

pub(crate) comptime fn create_public_stub(f: FunctionDefinition) -> Quoted {
    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =
        create_stub_base(f);
    let fn_return_type = f.return_type();

    quote {
        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::PublicCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {
            $serialized_args_array_construction
            let selector = $FROM_FIELD($fn_selector);
            dep::aztec::context::calls::PublicCall::new(
                self.target_contract,
                selector,
                $fn_name_str,
                $serialized_args_array_name,
            )
        }
    }
}

pub(crate) comptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {
    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =
        create_stub_base(f);
    let fn_return_type = f.return_type();

    quote {
        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::PublicStaticCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {
            $serialized_args_array_construction
            let selector = $FROM_FIELD($fn_selector);
            dep::aztec::context::calls::PublicStaticCall::new(
                self.target_contract,
                selector,
                $fn_name_str,
                $serialized_args_array_name,
            )
        }
    }
}

pub(crate) comptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {
    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =
        create_stub_base(f);
    let fn_return_type = f.return_type();

    quote {
        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::UtilityCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {
            $serialized_args_array_construction
            let selector = $FROM_FIELD($fn_selector);
            dep::aztec::context::calls::UtilityCall::new(
                self.target_contract,
                selector,
                $fn_name_str,
                $serialized_args_array_name,
            )
        }
    }
}

// Self-call stub generation functions for CallSelf, CallSelfStatic, EnqueueSelf, and EnqueueSelfStatic structs.
// Unlike the stubs above, the self-call stubs directly perform the call instead of returning a struct that can
// be later used to perform the call.

/// Creates a stub for calling a private function (or static private function if `is_static` is true) from private
/// context (for CallSelf<&mut PrivateContext> and CallSelfStatic<&mut PrivateContext>).
pub comptime fn create_private_self_call_stub(f: FunctionDefinition, is_static: bool) -> Quoted {
    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, _, _, _, fn_selector) =
        create_stub_base(f);
    let fn_return_type = f.return_type();

    quote {
        pub fn $fn_name(self, $fn_parameters_list) -> $fn_return_type {
            $serialized_args_array_construction
            let selector = $FROM_FIELD($fn_selector);
            let args_hash = aztec::hash::hash_args($serialized_args_array_name);
            aztec::oracle::execution_cache::store($serialized_args_array_name, args_hash);
            let returns_hash = self.context.call_private_function_with_args_hash(
                self.address,
                selector,
                args_hash,
                $is_static
            );
            returns_hash.get_preimage()
        }
    }
}

/// Creates a stub for calling a public function from public context (for CallSelf<PublicContext>)
pub comptime fn create_public_self_call_stub(f: FunctionDefinition) -> Quoted {
    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, _, fn_name_str, _, fn_selector) =
        create_stub_base(f);
    let fn_return_type = f.return_type();

    // TODO: It makes sense to drop the use of PublicStaticCall struct here and just perform the call directly but
    // before doing that we need to drop the use of slices from return values because we cannot return slices from
    // an unconstrained function. This is not a priority right now.
    quote {
        pub fn $fn_name(self, $fn_parameters_list) -> $fn_return_type {
            $serialized_args_array_construction
            let selector = $FROM_FIELD($fn_selector);
            unsafe {
                aztec::context::calls::PublicCall::new(
                    self.address,
                    selector,
                    $fn_name_str,
                    $serialized_args_array_name,
                ).call(self.context)
            }
        }
    }
}

/// Creates a static stub for calling a public view function from public context (for CallSelfStatic<PublicContext>)
pub comptime fn create_public_self_call_static_stub(f: FunctionDefinition) -> Quoted {
    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, _, fn_name_str, _, fn_selector) =
        create_stub_base(f);
    let fn_return_type = f.return_type();

    // TODO: It makes sense to drop the use of PublicStaticCall struct here and just perform the call directly but
    // before doing that we need to drop the use of slices from return values because we cannot return slices from
    // an unconstrained function. This is not a priority right now.
    quote {
        pub fn $fn_name(self, $fn_parameters_list) -> $fn_return_type {
            $serialized_args_array_construction
            let selector = $FROM_FIELD($fn_selector);
            unsafe {
                aztec::context::calls::PublicStaticCall::new(
                    self.address,
                    selector,
                    $fn_name_str,
                    $serialized_args_array_name,
                ).view(self.context)
            }
        }
    }
}

/// Creates a static stub for enqueuing a public view function from private context (for EnqueueSelfStatic<&mut PrivateContext>)
pub comptime fn create_public_self_enqueue_static_stub(f: FunctionDefinition) -> Quoted {
    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, _serialized_args_array_len, _fn_name_str, _fn_name_len, fn_selector) =
        create_stub_base(f);

    quote {
        pub fn $fn_name(self, $fn_parameters_list) {
            $serialized_args_array_construction
            let selector = $FROM_FIELD($fn_selector);
            let calldata = [aztec::protocol_types::traits::ToField::to_field(selector)].concat($serialized_args_array_name);
            let calldata_hash = aztec::hash::hash_calldata_array(calldata);
            aztec::oracle::execution_cache::store(calldata, calldata_hash);
            self.context.call_public_function_with_calldata_hash(
                self.address,
                calldata_hash,
                /*is_static_call=*/ true,
                /*hide_msg_sender=*/ false,
            );
        }
    }
}

/// Creates a stub for enqueuing a public function from private context (for EnqueueSelf<&mut PrivateContext>)
pub comptime fn create_public_self_enqueue_stub(f: FunctionDefinition) -> Quoted {
    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, _serialized_args_array_len, _fn_name_str, _fn_name_len, fn_selector) =
        create_stub_base(f);

    quote {
        pub fn $fn_name(self, $fn_parameters_list) {
            $serialized_args_array_construction
            let selector = $FROM_FIELD($fn_selector);
            let calldata = [aztec::protocol_types::traits::ToField::to_field(selector)].concat($serialized_args_array_name);
            let calldata_hash = aztec::hash::hash_calldata_array(calldata);
            aztec::oracle::execution_cache::store(calldata, calldata_hash);
            self.context.call_public_function_with_calldata_hash(
                self.address,
                calldata_hash,
                /*is_static_call=*/ false,
                /*hide_msg_sender=*/ false,
            );
        }
    }
}
