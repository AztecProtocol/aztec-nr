//! Stubs are auto-generated wrapper functions that provide an ergonomic interface for cross-contract calls.
//! Instead of manually serializing arguments and creating call interfaces, stubs allow natural syntax, e.g. for
//! enqueuing calls to public functions:
//!
//!   ExternalContract.at(address).some_method(arg1, arg2).enqueue()

use crate::macros::{
    functions::{self_call_registry, stub_registry as call_registry},
    utils::{AsStrQuote, compute_fn_selector, is_fn_view},
};
use protocol_types::meta::utils::derive_serialization_quotes;
use std::meta::unquote;

comptime global FROM_FIELD: TypedExpr = {
    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();
    let function_selector_typ =
        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();
    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {
        m.name() == quote { from_field }
    })[0]
        .as_typed_expr()
};

// Call registry is used to register calls to the contract from other contracts.
// Self-call registry is used to register calls to the contract from itself.

pub comptime fn register_private_fn_stubs(f: FunctionDefinition) {
    if is_fn_view(f) {
        call_registry::register(f.module(), create_private_static_stub(f));
        self_call_registry::register_call_self_private_static(
            f.module(),
            create_private_self_call_stub(f, true),
        );
    } else {
        call_registry::register(f.module(), create_private_stub(f));
        self_call_registry::register_call_self_private(
            f.module(),
            create_private_self_call_stub(f, false),
        );
    };
}

pub comptime fn register_public_fn_stubs(f: FunctionDefinition) {
    if is_fn_view(f) {
        call_registry::register(f.module(), create_public_static_stub(f));
        self_call_registry::register_call_self_public_static(
            f.module(),
            create_public_self_call_static_stub(f),
        );
        self_call_registry::register_enqueue_self_static(
            f.module(),
            create_public_self_enqueue_static_stub(f),
        );
    } else {
        call_registry::register(f.module(), create_public_stub(f));
        self_call_registry::register_call_self_public(f.module(), create_public_self_call_stub(f));
        self_call_registry::register_enqueue_self(f.module(), create_public_self_enqueue_stub(f));
    };
}

pub comptime fn register_utility_fn_stub(f: FunctionDefinition) {
    call_registry::register(f.module(), create_utility_stub(f));
}

/// Utility function creating stubs used by all the stub functions in this file.
comptime fn create_stub_base(
    f: FunctionDefinition,
) -> (Quoted, Quoted, Quoted, Quoted, Quoted, u32, Field) {
    // Dear privacy adventurer,
    // Chances are, you've command+clicked on the name of an external function
    // call -- seeking to view that function -- only to end up here.
    // Here's an explanation:
    // The external contract that you're calling was likely annotated with the `#[aztec]`
    // annotation -- as all good aztec contracts are. This triggers a macro which generates
    // a "contract interface" for that contract, which is effectively a pretty interface
    // that gives natural contract calling semantics:
    //
    // `MyImportedContract.at(some_address).my_method(arg1, arg2).enqueue();
    //
    // Unfortunately, the usage of macros makes it a bit of a black box.
    // To actually view the target function, you could instead command+click on
    // `MyImportedContract`, or you can just manually search it.
    // If you want to view the noir code that gets generated by this macro, you can
    // use `nargo expand` on your contract.
    let fn_name = f.name();
    let fn_parameters = f.parameters();
    let fn_parameters_list =
        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});

    let (serialized_args_array_construction, _, serialized_args_array_name) =
        derive_serialization_quotes(fn_parameters, false);

    let (fn_name_str, _) = fn_name.as_str_quote();
    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});
    let fn_selector: Field = compute_fn_selector(f);

    (
        fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name,
        fn_name_str, fn_name_len, fn_selector,
    )
}

comptime fn create_private_stub(f: FunctionDefinition) -> Quoted {
    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =
        create_stub_base(f);
    let fn_return_type = f.return_type();

    quote {
        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {
            $serialized_args_array_construction
            let selector = $FROM_FIELD($fn_selector);
            dep::aztec::context::call_interfaces::PrivateCallInterface::new(
                self.target_contract,
                selector,
                $fn_name_str,
                $serialized_args_array_name,
                false
            )
        }
    }
}

comptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {
    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =
        create_stub_base(f);
    let fn_return_type = f.return_type();

    quote {
        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {
            $serialized_args_array_construction
            let selector = $FROM_FIELD($fn_selector);
            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(
                self.target_contract,
                selector,
                $fn_name_str,
                $serialized_args_array_name,
            )
        }
    }
}

comptime fn create_public_stub(f: FunctionDefinition) -> Quoted {
    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =
        create_stub_base(f);
    let fn_return_type = f.return_type();

    quote {
        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {
            $serialized_args_array_construction
            let selector = $FROM_FIELD($fn_selector);
            dep::aztec::context::call_interfaces::PublicCallInterface::new(
                self.target_contract,
                selector,
                $fn_name_str,
                $serialized_args_array_name,
                false
            )
        }
    }
}

comptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {
    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =
        create_stub_base(f);
    let fn_return_type = f.return_type();

    quote {
        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {
            $serialized_args_array_construction
            let selector = $FROM_FIELD($fn_selector);
            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(
                self.target_contract,
                selector,
                $fn_name_str,
                $serialized_args_array_name,
            )
        }
    }
}

comptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {
    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =
        create_stub_base(f);
    let fn_return_type = f.return_type();

    quote {
        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type> {
            $serialized_args_array_construction
            let selector = $FROM_FIELD($fn_selector);
            dep::aztec::context::call_interfaces::UtilityCallInterface::new(
                self.target_contract,
                selector,
                $fn_name_str,
                $serialized_args_array_name,
            )
        }
    }
}

// Self-call stub generation functions for CallSelf, CallSelfStatic, EnqueueSelf and EnqueueSelfStatic structs

// Note: Unlike for the call registry, the self-call registry stubs directly perform the call instead of returning a
// call interface struct.
// TODO(F-131): This ^ is confusing and should be reflected in the naming.

/// Creates a stub for calling a private function (or static private function if `is_static` is true) from private
/// context (for CallSelf<&mut PrivateContext> and CallSelfStatic<&mut PrivateContext>).
pub comptime fn create_private_self_call_stub(f: FunctionDefinition, is_static: bool) -> Quoted {
    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, _, _, fn_selector) =
        create_stub_base(f);
    let fn_return_type = f.return_type();

    quote {
        pub fn $fn_name(self, $fn_parameters_list) -> $fn_return_type {
            $serialized_args_array_construction
            let selector = $FROM_FIELD($fn_selector);
            let args_hash = aztec::hash::hash_args($serialized_args_array_name);
            aztec::oracle::execution_cache::store($serialized_args_array_name, args_hash);
            let returns_hash = self.context.call_private_function_with_args_hash(
                self.address,
                selector,
                args_hash,
                $is_static
            );
            returns_hash.get_preimage()
        }
    }
}

// TODO(F-131): Drop the use of the CallInterface in the following 4 functions - it doesn't make sense to not not
// perform the call directly using the context. I tried doing this already but it became a lot of pain due to the use of
// slices and them being illegal to return from unconstrained functions. Makes sense to tackle this when cleaning up the
// call interface code.
// Note: Once we get rid of the structs we will be able to merge some of the static and non-static stub functions.

/// Creates a stub for calling a public function from public context (for CallSelf<PublicContext>)
pub comptime fn create_public_self_call_stub(f: FunctionDefinition) -> Quoted {
    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, fn_name_str, _, fn_selector) =
        create_stub_base(f);
    let fn_return_type = f.return_type();

    quote {
        pub fn $fn_name(self, $fn_parameters_list) -> $fn_return_type {
            $serialized_args_array_construction
            let selector = $FROM_FIELD($fn_selector);
            unsafe {
                aztec::context::call_interfaces::PublicCallInterface::new(
                    self.address,
                    selector,
                    $fn_name_str,
                    $serialized_args_array_name,
                    false
                ).call(self.context)
            }
        }
    }
}

/// Creates a static stub for calling a public view function from public context (for CallSelfStatic<PublicContext>)
pub comptime fn create_public_self_call_static_stub(f: FunctionDefinition) -> Quoted {
    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, fn_name_str, _, fn_selector) =
        create_stub_base(f);
    let fn_return_type = f.return_type();

    quote {
        pub fn $fn_name(self, $fn_parameters_list) -> $fn_return_type {
            $serialized_args_array_construction
            let selector = $FROM_FIELD($fn_selector);
            unsafe {
                aztec::context::call_interfaces::PublicStaticCallInterface::new(
                    self.address,
                    selector,
                    $fn_name_str,
                    $serialized_args_array_name,
                ).view(self.context)
            }
        }
    }
}

/// Creates a static stub for enqueuing a public view function from private context (for EnqueueSelfStatic<&mut PrivateContext>)
pub comptime fn create_public_self_enqueue_static_stub(f: FunctionDefinition) -> Quoted {
    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =
        create_stub_base(f);

    quote {
        pub fn $fn_name(self, $fn_parameters_list) {
            $serialized_args_array_construction
            let selector = $FROM_FIELD($fn_selector);
            let interface: aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, ()> = aztec::context::call_interfaces::PublicStaticCallInterface::new(
                self.address,
                selector,
                $fn_name_str,
                $serialized_args_array_name,
            );
            interface.enqueue_view(self.context);
        }
    }
}

/// Creates a stub for enqueuing a public function from private context (for EnqueueSelf<&mut PrivateContext>)
pub comptime fn create_public_self_enqueue_stub(f: FunctionDefinition) -> Quoted {
    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =
        create_stub_base(f);

    quote {
        pub fn $fn_name(self, $fn_parameters_list) {
            $serialized_args_array_construction
            let selector = $FROM_FIELD($fn_selector);
            let interface: aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, ()> = aztec::context::call_interfaces::PublicCallInterface::new(
                self.address,
                selector,
                $fn_name_str,
                $serialized_args_array_name,
                false
            );
            interface.enqueue(self.context);
        }
    }
}
