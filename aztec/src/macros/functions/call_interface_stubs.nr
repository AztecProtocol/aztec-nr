//! Stubs are auto-generated wrapper functions that provide an ergonomic interface for cross-contract calls.
//! Instead of manually serializing arguments and creating call interfaces, stubs allow natural syntax, e.g. for
//! enqueuing calls to public functions:
//!
//!   ExternalContract.at(address).some_method(arg1, arg2).enqueue()

use crate::macros::utils::{AsStrQuote, compute_fn_selector, is_fn_view};
use super::stub_registry;
use protocol_types::meta::utils::derive_serialization_quotes;
use std::meta::unquote;

comptime global FROM_FIELD: TypedExpr = {
    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();
    let function_selector_typ =
        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();
    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {
        m.name() == quote { from_field }
    })[0]
        .as_typed_expr()
};

pub comptime fn register_private_fn_stub(f: FunctionDefinition) {
    let stub = if is_fn_view(f) {
        create_private_static_stub(f)
    } else {
        create_private_stub(f)
    };
    stub_registry::register(f.module(), stub);
}

pub comptime fn register_public_fn_stub(f: FunctionDefinition) {
    let stub = if is_fn_view(f) {
        create_public_static_stub(f)
    } else {
        create_public_stub(f)
    };
    stub_registry::register(f.module(), stub);
}

pub comptime fn register_utility_fn_stub(f: FunctionDefinition) {
    let stub = create_utility_stub(f);
    stub_registry::register(f.module(), stub);
}

/// Utility function creating stubs used by all the stub functions in this file.
comptime fn create_stub_base(
    f: FunctionDefinition,
) -> (Quoted, Quoted, Quoted, Quoted, Quoted, u32, Field) {
    // Dear privacy adventurer,
    // Chances are, you've command+clicked on the name of an external function
    // call -- seeking to view that function -- only to end up here.
    // Here's an explanation:
    // The external contract that you're calling was likely annotated with the `#[aztec]`
    // annotation -- as all good aztec contracts are. This triggers a macro which generates
    // a "contract interface" for that contract, which is effectively a pretty interface
    // that gives natural contract calling semantics:
    //
    // `MyImportedContract.at(some_address).my_method(arg1, arg2).enqueue();
    //
    // Unfortunately, the usage of macros makes it a bit of a black box.
    // To actually view the target function, you could instead command+click on
    // `MyImportedContract`, or you can just manually search it.
    // If you want to view the noir code that gets generated by this macro, you can
    // use `nargo expand` on your contract.
    let fn_name = f.name();
    let fn_parameters = f.parameters();
    let fn_parameters_list =
        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});

    let (serialized_args_array_construction, _, serialized_args_array_name) =
        derive_serialization_quotes(fn_parameters, false);

    let (fn_name_str, _) = fn_name.as_str_quote();
    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});
    let fn_selector: Field = compute_fn_selector(f);

    (
        fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name,
        fn_name_str, fn_name_len, fn_selector,
    )
}

comptime fn create_private_stub(f: FunctionDefinition) -> Quoted {
    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =
        create_stub_base(f);
    let fn_return_type = f.return_type();

    quote {
        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {
            $serialized_args_array_construction
            let selector = $FROM_FIELD($fn_selector);
            dep::aztec::context::call_interfaces::PrivateCallInterface::new(
                self.target_contract,
                selector,
                $fn_name_str,
                $serialized_args_array_name,
                false
            )
        }
    }
}

comptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {
    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =
        create_stub_base(f);
    let fn_return_type = f.return_type();

    quote {
        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {
            $serialized_args_slice_construction
            let selector = $FROM_FIELD($fn_selector);
            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(
                self.target_contract,
                selector,
                $fn_name_str,
                $serialized_args_array_name,
            )
        }
    }
}

comptime fn create_public_stub(f: FunctionDefinition) -> Quoted {
    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =
        create_stub_base(f);
    let fn_return_type = f.return_type();

    quote {
        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {
            $serialized_args_slice_construction
            let selector = $FROM_FIELD($fn_selector);
            dep::aztec::context::call_interfaces::PublicCallInterface::new(
                self.target_contract,
                selector,
                $fn_name_str,
                $serialized_args_array_name,
                false
            )
        }
    }
}

comptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {
    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =
        create_stub_base(f);
    let fn_return_type = f.return_type();

    quote {
        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {
            $serialized_args_slice_construction
            let selector = $FROM_FIELD($fn_selector);
            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(
                self.target_contract,
                selector,
                $fn_name_str,
                $serialized_args_array_name,
            )
        }
    }
}

comptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {
    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =
        create_stub_base(f);
    let fn_return_type = f.return_type();

    quote {
        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type> {
            $serialized_args_slice_construction
            let selector = $FROM_FIELD($fn_selector);
            dep::aztec::context::call_interfaces::UtilityCallInterface::new(
                self.target_contract,
                selector,
                $fn_name_str,
                $serialized_args_array_name,
            )
        }
    }
}
