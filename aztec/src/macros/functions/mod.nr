pub(crate) mod abi_export;
pub(crate) mod call_interface_stubs;
// TODO: Move initialization_utils out of this crate
// See https://github.com/AztecProtocol/aztec-packages/pull/15856#discussion_r2229134689 for more details
pub mod initialization_utils;
pub(crate) mod stub_registry;
pub(crate) mod auth_registry;
pub(crate) mod utils;

use crate::macros::{
    functions::{
        abi_export::create_fn_abi_export,
        utils::{transform_private, transform_public, transform_utility},
    },
    utils::{is_fn_external, module_has_initializer},
};
use super::utils::{fn_has_noinitcheck, is_fn_initializer, is_fn_only_self, is_fn_view};
use auth_registry::AUTHORIZE_ONCE_REGISTRY;

// Functions can have multiple attributes applied to them, e.g. a single function can have #[external("public")],
// #[view] and #[only_self]. However. the order in which this will be evaluated is unknown, which makes combining them
// tricky.
//
// Our strategy is to have functions accept at most one #[external(...)] attribute that takes a parameter ("private",
// "public", or "utility") to specify the function type. The private and public handlers that are triggered based on
// the arg of #[external(...)] attribute contains the code for all other attributes, but they only run if
// the corresponding marker attribute has been applied to the function.
//
// For example, the "private" handler of #[external(...)] knows about #[only_self] and what it should do, but it only
// does it if it sees that the private function in question also has the `only_self` attribute applied. `#[only_self]`
// itself does nothing - it is what we call a 'marker' attribute, that only exists for `#[external("private")]`
// and `#[external(public)]` to check if it's been applied. Therefore, the execution order of `#[only_self]` and
// `#[external(...)]` is irrelevant.

/// An initializer function is similar to a constructor:
///  - it can only be called once
///  - if there are multiple initializer functions, only one of them can be called
///  - no non-initializer functions can be called until an initializer has ben called (except `noinitcheck` functions)
pub comptime fn initializer(f: FunctionDefinition) {
    // Marker attribute - see the comment above

    if !is_fn_external(f) {
        // Unfortunately we cannot check if we are dealing with a utility function here as Noir does not support
        // getting arguments passed to attributes. For this reason, we will check for this when the utility macro
        // function is run.
        let name = f.name();
        panic(
            f"The #[initializer] attribute can only be applied to #[external(\"private\")] or #[external(\"public\")] functions - {name} is neither",
        );
    }
}

/// Functions with noinitcheck can be called before contract initialization.
pub comptime fn noinitcheck(f: FunctionDefinition) {
    // Marker attribute - see the comment above

    if !is_fn_external(f) {
        // Unfortunately we cannot check if we are dealing with a utility function here as Noir does not support
        // getting arguments passed to attributes. For this reason, we will check for this when the utility macro
        // function is run.
        let name = f.name();
        panic(
            f"The #[noinitcheck] attribute can only be applied to #[external(\"private\")] or #[external(\"public\")] functions - {name} is neither",
        );
    }

    if !module_has_initializer(f.module()) {
        panic(
            f"The #[noinitcheck] attribute is unnecessary for contracts with no #[initializer] functions",
        );
    }
}

/// Functions marked with #[only_self] attribute can only be called by the contract itself.
///
/// # Usage
/// This attribute is commonly used when an action starts in private but needs to be completed in public. The public
/// function must be marked with #[only_self] to restrict access to only the contract itself. A typical example is a
/// private token mint operation that needs to enqueue a call to a public function to update the publicly tracked total
/// token supply.
pub comptime fn only_self(f: FunctionDefinition) {
    // Marker attribute - see the comment above

    if !is_fn_external(f) {
        // Unfortunately we cannot check if we are dealing with a utility function here as Noir does not support
        // getting arguments passed to attributes. For this reason, we will check for this when the utility macro
        // function is run.
        let name = f.name();
        panic(
            f"The #[only_self] attribute can only be applied to #[external(\"private\")] or #[external(\"public\")] functions - {name} is neither",
        );
    }
}

/// View functions can only be called in a static execution context.
pub comptime fn view(f: FunctionDefinition) {
    // Marker attribute - see the comment above

    if !is_fn_external(f) {
        // Unfortunately we cannot check if we are dealing with a utility function here as Noir does not support
        // getting arguments passed to attributes. For this reason, we will check for this when the utility macro
        // function is run.
        let name = f.name();
        panic(
            f"The #[view] attribute can only be applied to #[external(\"private\")] or #[external(\"public\")] functions - {name} is neither",
        );
    }
}

/// Private and public functions can require an authorization check to be performed before execution. This
/// is typically the case when the function allows performing an action on behalf of someone who is not
/// the caller.
/// This macro injects the necessary code to perform the check via the authwit mechanism and additionally
/// emit the authorization request as an offchain effect, so a user/wallet can verify what are they
/// being asked to sign.
/// This check also emits a nullifier with the provided nonce argument, so authorizations are valid
/// once and only once, preventing replay attacks.
pub comptime fn authorize_once(
    f: FunctionDefinition,
    from_arg_name: CtString,
    nonce_arg_name: CtString,
) {
    if !is_fn_external(f) {
        // Unfortunately we cannot check if we are dealing with a utility function here as Noir does not support
        // getting arguments passed to attributes. For this reason, we will check for this when the utility macro
        // function is run.
        let name = f.name();
        panic(
            f"The #[authorize_once] attribute can only be applied to #[external(\"private\")] or #[external(\"public\")] functions - {name} is neither",
        );
    }

    AUTHORIZE_ONCE_REGISTRY.insert(f, (from_arg_name, nonce_arg_name));
}

/// Same as in Solidity external functions are functions that our callable from outside the contract. External
/// functions can be either private, public, or utility.
pub comptime fn external(f: FunctionDefinition, f_type: CtString) -> Quoted {
    if f_type.eq("private") {
        private(f)
    } else if f_type.eq("public") {
        public(f)
    } else if f_type.eq("utility") {
        utility(f)
    } else {
        let function_name = f.name();
        panic(
            f"Function '{function_name}' is marked as #[external(\"{f_type}\")], but '{f_type}' is not a valid external function type. External functions must be one of 'private', 'public' or 'utility'",
        );
        quote {}
    }
}

/// Private functions are executed client-side and preserve privacy.
comptime fn private(f: FunctionDefinition) -> Quoted {
    // We need to add this attribute to be able to identify if the function is external private when constructing
    // the contract artifact.
    f.add_attribute("private");

    let visibility = f.visibility();
    if visibility != quote {} {
        let name = f.name();
        panic(
            f"A function marked as #[external(\"private\")] must not have public Noir visibility - {name}'s visibility is '{visibility}'",
        );
    }

    if f.is_unconstrained() {
        let name = f.name();
        panic(
            f"#[external(\"private\")] functions must not be unconstrained - {name} is",
        );
    }

    // The abi export function is expected to be executed before the function is transformed.
    let fn_abi_export = create_fn_abi_export(f);

    transform_private(f);

    fn_abi_export
}

/// Public functions are executed sequencer-side and do not preserve privacy, similar to the EVM.
comptime fn public(f: FunctionDefinition) -> Quoted {
    // We need to add this attribute to be able to identify if the function is external public when constructing
    // the contract artifact.
    f.add_attribute("public");

    // We don't want to transform the public_dispatch function.
    if f.name() == quote { public_dispatch } {
        quote {}
    } else {
        let visibility = f.visibility();
        if visibility != quote {} {
            let name = f.name();
            panic(
                f"A function marked as #[external(\"public\")] must not have public Noir visibility - {name}'s visibility is '{visibility}'",
            );
        }

        if f.is_unconstrained() {
            let name = f.name();
            panic(
                f"#[external(\"public\")] functions must not be unconstrained - {name} is",
            );
        }

        // The abi export function is expected to be executed before the function is transformed.
        let fn_abi_export = create_fn_abi_export(f);

        transform_public(f);

        fn_abi_export
    }
}

/// Utility functions are standalone unconstrained functions that cannot be called from another function in a contract.
/// They are typically used either to obtain some information from the contract (e.g. token balance of a user) or to
/// modify internal contract-related state of PXE (e.g. processing logs in Aztec.nr during sync).
comptime fn utility(f: FunctionDefinition) -> Quoted {
    // We need to add this attribute to be able to identify if the function is external utility when constructing
    // the contract artifact.
    f.add_attribute("utility");

    let visibility = f.visibility();
    if visibility != quote {} {
        let name = f.name();
        panic(
            f"A function marked as #[external(\"utility\")] must not have public Noir visibility - {name}'s visibility is '{visibility}'",
        );
    }

    if !f.is_unconstrained() {
        let name = f.name();
        panic(
            f"#[external(\"utility\")] must be unconstrained - {name} isn't",
        );
    }

    post_external_utility_checks(f);

    // The abi export function is expected to be executed before the function is transformed.
    let fn_abi_export = create_fn_abi_export(f);

    transform_utility(f);

    fn_abi_export
}

/// Utility functions cannot be used with the following modifiers: #[authorize_once], #[only_self], #[view],
/// #[initializer], and #[noinitcheck]. Since we cannot enforce a specific ordering between these modifiers and
/// #[external(...)], and we cannot access the #[external(...)] argument from within these modifiers' implementations
/// (as accessing EXTERNAL_REGISTRY would require enforcing ordering), we perform these compatibility checks here in
/// the utility macro.
comptime fn post_external_utility_checks(f: FunctionDefinition) {
    if AUTHORIZE_ONCE_REGISTRY.get(f).is_some() {
        let name = f.name();
        panic(
            f"The #[authorize_once] attribute cannot be applied to #[external(\"utility\")] functions - {name}",
        );
    }

    if is_fn_only_self(f) {
        let name = f.name();
        panic(
            f"The #[only_self] attribute cannot be applied to #[external(\"utility\")] functions - {name}",
        );
    }

    if is_fn_view(f) {
        let name = f.name();
        panic(
            f"The #[view] attribute cannot be applied to #[external(\"utility\")] functions - {name}",
        );
    }

    if is_fn_initializer(f) {
        let name = f.name();
        panic(
            f"The #[initializer] attribute cannot be applied to #[external(\"utility\")] functions - {name}",
        );
    }

    if fn_has_noinitcheck(f) {
        let name = f.name();
        panic(
            f"The #[noinitcheck] attribute cannot be applied to #[external(\"utility\")] functions - {name}",
        );
    }
}
